(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["tauri"] = factory();
	else
		root["tauri"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/helpers/app-paths.ts":
/*!**********************************!*\
  !*** ./src/helpers/app-paths.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolve = exports.tauriDir = exports.appDir = void 0;
var fs_1 = __webpack_require__(/*! fs */ "fs");
var path_1 = __webpack_require__(/*! path */ "path");
var logger_1 = __importDefault(__webpack_require__(/*! ./logger */ "./src/helpers/logger.ts"));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var warn = logger_1.default('tauri', chalk_1.default.red);
function resolvePath(basePath, dir) {
    return dir && path_1.isAbsolute(dir) ? dir : path_1.resolve(basePath, dir);
}
var getAppDir = function () {
    var dir = process.cwd();
    var count = 0;
    // only go up three folders max
    while (dir.length > 0 && !dir.endsWith(path_1.sep) && count <= 2) {
        if (fs_1.existsSync(path_1.join(dir, 'src-tauri', 'tauri.conf.json'))) {
            return dir;
        }
        count++;
        dir = path_1.normalize(path_1.join(dir, '..'));
    }
    warn("Couldn't find recognize the current folder as a part of a Tauri project");
    process.exit(1);
};
var appDir = getAppDir();
exports.appDir = appDir;
var tauriDir = path_1.resolve(appDir, 'src-tauri');
exports.tauriDir = tauriDir;
var resolveDir = {
    app: function (dir) { return resolvePath(appDir, dir); },
    tauri: function (dir) { return resolvePath(tauriDir, dir); }
};
exports.resolve = resolveDir;


/***/ }),

/***/ "./src/helpers/logger.ts":
/*!*******************************!*\
  !*** ./src/helpers/logger.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var ms_1 = __importDefault(__webpack_require__(/*! ms */ "ms"));
var prevTime;
exports.default = (function (banner, color) {
    if (color === void 0) { color = chalk_1.default.green; }
    return function (msg) {
        var curr = +new Date();
        var diff = curr - (prevTime || curr);
        prevTime = curr;
        if (msg) {
            console.log(
            // TODO: proper typings for color and banner
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call
            " " + color(String(banner)) + " " + msg + " " + chalk_1.default.green("+" + ms_1.default(diff)));
        }
        else {
            console.log();
        }
    };
});


/***/ }),

/***/ "./src/helpers/non-webpack-require.ts":
/*!********************************************!*\
  !*** ./src/helpers/non-webpack-require.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// this function has been moved to a module so we can mock it
exports.default = (function (path) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return require(path);
});


/***/ }),

/***/ "./src/helpers/tauri-config.ts":
/*!*************************************!*\
  !*** ./src/helpers/tauri-config.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var fs_extra_1 = __webpack_require__(/*! fs-extra */ "fs-extra");
var webpack_merge_1 = __webpack_require__(/*! webpack-merge */ "webpack-merge");
var logger_1 = __importDefault(__webpack_require__(/*! ../helpers/logger */ "./src/helpers/logger.ts"));
var appPaths = __importStar(__webpack_require__(/*! ./app-paths */ "./src/helpers/app-paths.ts"));
var non_webpack_require_1 = __importDefault(__webpack_require__(/*! ../helpers/non-webpack-require */ "./src/helpers/non-webpack-require.ts"));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var config_validator_1 = __webpack_require__(/*! ../types/config.validator */ "./src/types/config.validator.ts");
var error = logger_1.default('ERROR:', chalk_1.default.red);
var getTauriConfig = function (cfg) {
    var _a, _b, _c;
    var pkgPath = appPaths.resolve.app('package.json');
    var tauriConfPath = appPaths.resolve.tauri('tauri.conf.json');
    if (!fs_extra_1.existsSync(tauriConfPath)) {
        error("Could not find a tauri config (tauri.conf.json) in your app's directory.");
        process.exit(1);
    }
    var tauriConf = JSON.parse(fs_extra_1.readFileSync(tauriConfPath).toString());
    var pkg = fs_extra_1.existsSync(pkgPath)
        ? non_webpack_require_1.default(pkgPath)
        : null;
    var config = webpack_merge_1.merge({
        build: {},
        ctx: {},
        tauri: {
            embeddedServer: {
                active: true
            },
            bundle: {
                active: true,
                icon: [],
                resources: [],
                externalBin: [],
                deb: {
                    depends: []
                },
                osx: {
                    frameworks: []
                }
            },
            allowlist: {
                all: false
            },
            window: {
                title: (_a = pkg === null || pkg === void 0 ? void 0 : pkg.productName) !== null && _a !== void 0 ? _a : 'Tauri App'
            },
            security: {
                csp: "default-src blob: data: filesystem: ws: http: https: 'unsafe-eval' 'unsafe-inline'"
            },
            inliner: {
                active: true
            }
        }
    }, tauriConf, cfg);
    if (!config_validator_1.isTauriConfig(config)) {
        var messages = config_validator_1.ajv
            .errorsText((_b = config_validator_1.isTauriConfig.errors) === null || _b === void 0 ? void 0 : _b.filter(function (e) { return e.keyword !== 'if'; }).map(function (e) {
            e.dataPath = e.dataPath.replace(/\./g, ' > ');
            if (e.keyword === 'additionalProperties' &&
                typeof e.message === 'string' &&
                'additionalProperty' in e.params) {
                e.message = "has unknown property " + e.params.additionalProperty;
            }
            return e;
        }), { dataVar: 'tauri.conf.json', separator: '\n' })
            .split('\n');
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var message = messages_1[_i];
            error(message);
        }
        process.exit(1);
    }
    var runningDevServer = (_c = config.build.devPath) === null || _c === void 0 ? void 0 : _c.startsWith('http');
    if (!runningDevServer) {
        config.build.devPath = appPaths.resolve.tauri(config.build.devPath);
        process.env.TAURI_DIST_DIR = config.build.devPath;
    }
    if (config.build.distDir) {
        config.build.distDir = appPaths.resolve.tauri(config.build.distDir);
        process.env.TAURI_DIST_DIR = config.build.distDir;
    }
    // OSX bundle config
    if (config.tauri.bundle.osx) {
        var license = config.tauri.bundle.osx.license;
        if (typeof license === 'string') {
            config.tauri.bundle.osx.license = appPaths.resolve.tauri(license);
        }
        else if (license !== null) {
            var licensePath = appPaths.resolve.app('LICENSE');
            if (fs_extra_1.existsSync(licensePath)) {
                config.tauri.bundle.osx.license = licensePath;
            }
        }
    }
    // bundle targets
    if (Array.isArray(config.tauri.bundle.targets)) {
        if (process.platform !== 'win32') {
            config.tauri.bundle.targets = config.tauri.bundle.targets.filter(function (t) { return t !== 'msi'; });
        }
    }
    process.env.TAURI_DIR = appPaths.tauriDir;
    process.env.TAURI_CONFIG = JSON.stringify(config);
    return config;
};
exports.default = getTauriConfig;


/***/ }),

/***/ "./src/types/config.validator.ts":
/*!***************************************!*\
  !*** ./src/types/config.validator.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTauriConfig = exports.TauriConfigSchema = exports.ajv = void 0;
/* tslint:disable */
// generated by typescript-json-validator
var util_1 = __webpack_require__(/*! util */ "util");
var ajv_1 = __importDefault(__webpack_require__(/*! ajv */ "ajv"));
exports.ajv = new ajv_1.default({
    allErrors: true,
    coerceTypes: false,
    format: 'fast',
    nullable: true,
    unicode: true,
    uniqueItems: true,
    useDefaults: true
});
exports.ajv.addMetaSchema(__webpack_require__(/*! ajv/lib/refs/json-schema-draft-06.json */ "ajv/lib/refs/json-schema-draft-06.json"));
exports.TauriConfigSchema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    additionalProperties: false,
    defaultProperties: [],
    definitions: {
        CliArg: {
            additionalProperties: false,
            defaultProperties: [],
            description: 'A CLI argument definition',
            properties: {
                conflictsWith: {
                    description: "sets a conflicting argument by name\ni.e. when using this argument, the following argument can't be present and vice versa",
                    type: 'string'
                },
                conflictsWithAll: {
                    description: 'the same as conflictsWith but allows specifying multiple two-way conflicts per argument',
                    type: 'string'
                },
                description: {
                    description: 'the argument description which will be shown on the help information\ntypically, this is a short (one line) description of the arg',
                    type: 'string'
                },
                index: {
                    description: 'The positional argument index, starting at 1.\n\nThe index refers to position according to other positional argument.\nIt does not define position in the argument list as a whole. When utilized with multiple=true,\nonly the last positional argument may be defined as multiple (i.e. the one with the highest index).',
                    type: 'number'
                },
                longDescription: {
                    description: 'the argument long description which will be shown on the help information\ntypically this a more detailed (multi-line) message that describes the argument',
                    type: 'string'
                },
                maxValues: {
                    description: "specifies the maximum number of values are for this argument.\nfor example, if you had a -f <file> argument where you wanted up to 3 'files' you would set .max_values(3), and this argument would be satisfied if the user provided, 1, 2, or 3 values.",
                    type: 'number'
                },
                minValues: {
                    description: "specifies the minimum number of values for this argument.\nfor example, if you had a -f <file> argument where you wanted at least 2 'files' you would set `minValues: 2`, and this argument would be satisfied if the user provided, 2 or more values.",
                    type: 'number'
                },
                multiple: {
                    description: 'specifies that the argument may appear more than once.\nfor flags, this results in the number of occurrences of the flag being recorded. For example -ddd or -d -d -d would count as three occurrences.\nfor options there is a distinct difference in multiple occurrences vs multiple values. For example, --opt val1 val2 is one occurrence, but two values. Whereas --opt val1 --opt val2 is two occurrences.',
                    type: 'boolean'
                },
                multipleOccurrences: {
                    description: 'specifies that the argument may appear more than once.',
                    type: 'boolean'
                },
                name: {
                    description: 'the unique argument name',
                    type: 'string'
                },
                possibleValues: {
                    description: 'specifies a list of possible values for this argument. At runtime, the CLI verifies that only one of the specified values was used, or fails with an error message.',
                    items: {
                        type: 'string'
                    },
                    type: 'array'
                },
                requireEquals: {
                    description: 'requires that options use the --option=val syntax\ni.e. an equals between the option and associated value',
                    type: 'boolean'
                },
                required: {
                    description: 'sets whether or not the argument is required by default\nrequired by default means it is required, when no other conflicting rules have been evaluated\nconflicting rules take precedence over being required.',
                    type: 'boolean'
                },
                requiredIf: {
                    additionalItems: {
                        anyOf: [
                            {
                                type: 'string'
                            },
                            {
                                type: 'string'
                            }
                        ]
                    },
                    description: "allows specifying that an argument is required conditionally with the signature [arg: string, value: string]\nthe requirement will only become valid if the `arg`'s value equals `${value}`.",
                    items: [
                        {
                            type: 'string'
                        },
                        {
                            type: 'string'
                        }
                    ],
                    minItems: 2,
                    type: 'array'
                },
                requiredUnless: {
                    description: "sets an arg that override this arg's required setting\ni.e. this arg will be required unless this other argument is present",
                    type: 'string'
                },
                requiredUnlessAll: {
                    description: "sets args that override this arg's required setting\ni.e. this arg will be required unless all these other arguments are present",
                    items: {
                        type: 'string'
                    },
                    type: 'array'
                },
                requiredUnlessOne: {
                    description: "sets args that override this arg's required setting\ni.e. this arg will be required unless at least one of these other arguments are present",
                    items: {
                        type: 'string'
                    },
                    type: 'array'
                },
                requires: {
                    description: 'sets an argument by name that is required when this one is present\ni.e. when using this argument, the following argument must be present',
                    type: 'string'
                },
                requiresAll: {
                    description: 'sets multiple arguments by names that are required when this one is present\ni.e. when using this argument, the following arguments must be present',
                    items: {
                        type: 'string'
                    },
                    type: 'array'
                },
                requiresIf: {
                    additionalItems: {
                        anyOf: [
                            {
                                type: 'string'
                            },
                            {
                                type: 'string'
                            }
                        ]
                    },
                    description: "allows a conditional requirement with the signature [arg: string, value: string]\nthe requirement will only become valid if `arg`'s value equals `${value}`",
                    items: [
                        {
                            type: 'string'
                        },
                        {
                            type: 'string'
                        }
                    ],
                    minItems: 2,
                    type: 'array'
                },
                short: {
                    description: 'the short version of the argument, without the preceding -\nNOTE: Any leading - characters will be stripped, and only the first non - character will be used as the short version',
                    type: 'string'
                },
                takesValue: {
                    description: 'specifies that the argument takes a value at run time.\nNOTE: values for arguments may be specified in any of the following methods\n- Using a space such as -o value or --option value\n- Using an equals and no space such as -o=value or --option=value\n- Use a short and no space such as -ovalue',
                    type: 'boolean'
                }
            },
            required: ['name'],
            type: 'object'
        },
        CliConfig: {
            additionalProperties: false,
            defaultProperties: [],
            description: 'describes a CLI configuration',
            properties: {
                afterHelp: {
                    description: 'adds additional help information to be displayed in addition to auto-generated help\nthis information is displayed after the auto-generated help information\nthis is often used to describe how to use the arguments, or caveats to be noted.',
                    type: 'string'
                },
                args: {
                    description: 'list of args for the command',
                    items: {
                        $ref: '#/definitions/CliArg'
                    },
                    type: 'array'
                },
                beforeHelp: {
                    description: 'adds additional help information to be displayed in addition to auto-generated help\nthis information is displayed before the auto-generated help information.\nthis is often used for header information',
                    type: 'string'
                },
                description: {
                    description: 'command description which will be shown on the help information',
                    type: 'string'
                },
                longDescription: {
                    description: 'command long description which will be shown on the help information',
                    type: 'string'
                },
                subcommands: {
                    additionalProperties: {
                        $ref: '#/definitions/CliConfig'
                    },
                    defaultProperties: [],
                    description: 'list of subcommands of this command\n\nsubcommands are effectively sub-apps, because they can contain their own arguments, subcommands, usage, etc.\nthey also function just like the app command, in that they get their own auto generated help and usage',
                    type: 'object'
                }
            },
            type: 'object'
        },
        TauriBuildConfig: {
            additionalProperties: false,
            defaultProperties: [],
            properties: {
                beforeBuildCommand: {
                    description: 'a shell command to run before `tauri build` kicks in',
                    type: 'string'
                },
                beforeDevCommand: {
                    description: 'a shell command to run before `tauri dev` kicks in',
                    type: 'string'
                },
                devPath: {
                    description: "the app's dev server URL, or the path to the directory containing an index.html to open",
                    type: 'string'
                },
                distDir: {
                    description: "the path to the app's dist dir\nthis path must contain your index.html file",
                    type: 'string'
                },
                withGlobalTauri: {
                    type: 'boolean'
                }
            },
            required: ['devPath', 'distDir'],
            type: 'object'
        }
    },
    description: 'Tauri configuration',
    properties: {
        build: {
            $ref: '#/definitions/TauriBuildConfig',
            description: 'build/dev configuration'
        },
        ctx: {
            additionalProperties: false,
            defaultProperties: [],
            description: 'the context of the current `tauri dev` or `tauri build`',
            properties: {
                debug: {
                    description: 'whether the app should be built on debug mode or not',
                    type: 'boolean'
                },
                dev: {
                    description: "whether we're running on the dev environment or not",
                    type: 'boolean'
                },
                exitOnPanic: {
                    description: 'defines we should exit the `tauri dev` process if a Rust code error is found',
                    type: 'boolean'
                },
                prod: {
                    description: "whether we're building for production or not",
                    type: 'boolean'
                },
                target: {
                    description: 'the target of the compilation (see `rustup target list`)',
                    type: 'string'
                }
            },
            type: 'object'
        },
        plugins: {
            additionalProperties: {
                additionalProperties: {},
                defaultProperties: [],
                type: 'object'
            },
            defaultProperties: [],
            type: 'object'
        },
        tauri: {
            additionalProperties: false,
            defaultProperties: [],
            description: 'tauri root configuration object',
            properties: {
                allowlist: {
                    additionalProperties: {
                        type: 'boolean'
                    },
                    defaultProperties: [],
                    properties: {
                        all: {
                            type: 'boolean'
                        }
                    },
                    required: ['all'],
                    type: 'object'
                },
                bundle: {
                    additionalProperties: false,
                    defaultProperties: [],
                    description: 'tauri bundler configuration',
                    properties: {
                        active: {
                            description: 'whether we should build your app with tauri-bundler or plain `cargo build`',
                            type: 'boolean'
                        },
                        category: {
                            type: 'string'
                        },
                        copyright: {
                            type: 'string'
                        },
                        deb: {
                            additionalProperties: false,
                            defaultProperties: [],
                            properties: {
                                depends: {
                                    items: {
                                        type: 'string'
                                    },
                                    type: 'array'
                                },
                                useBootstrapper: {
                                    type: 'boolean'
                                }
                            },
                            type: 'object'
                        },
                        exceptionDomain: {
                            type: 'string'
                        },
                        externalBin: {
                            items: {
                                type: 'string'
                            },
                            type: 'array'
                        },
                        icon: {
                            description: "the app's icons",
                            items: {
                                type: 'string'
                            },
                            type: 'array'
                        },
                        identifier: {
                            description: "the app's identifier",
                            type: 'string'
                        },
                        longDescription: {
                            type: 'string'
                        },
                        osx: {
                            additionalProperties: false,
                            defaultProperties: [],
                            properties: {
                                frameworks: {
                                    items: {
                                        type: 'string'
                                    },
                                    type: 'array'
                                },
                                license: {
                                    type: 'string'
                                },
                                minimumSystemVersion: {
                                    type: 'string'
                                },
                                useBootstrapper: {
                                    type: 'boolean'
                                }
                            },
                            type: 'object'
                        },
                        resources: {
                            description: 'app resources to bundle\neach resource is a path to a file or directory\nglob patterns are supported',
                            items: {
                                type: 'string'
                            },
                            type: 'array'
                        },
                        shortDescription: {
                            type: 'string'
                        },
                        targets: {
                            anyOf: [
                                {
                                    items: {
                                        type: 'string'
                                    },
                                    type: 'array'
                                },
                                {
                                    type: 'string'
                                }
                            ],
                            description: 'the bundle targets, currently supports ["deb", "osx", "msi", "appimage", "dmg"] or "all"'
                        }
                    },
                    required: ['icon', 'identifier'],
                    type: 'object'
                },
                cli: {
                    $ref: '#/definitions/CliConfig',
                    description: "app's CLI definition"
                },
                embeddedServer: {
                    additionalProperties: false,
                    defaultProperties: [],
                    description: 'the embedded server configuration',
                    properties: {
                        active: {
                            description: 'whether we should use the embedded-server or the no-server mode',
                            type: 'boolean'
                        },
                        port: {
                            anyOf: [
                                {
                                    enum: ['random'],
                                    type: 'string'
                                },
                                {
                                    type: 'number'
                                }
                            ],
                            description: "the embedded server port number or the 'random' string to generate one at runtime"
                        }
                    },
                    type: 'object'
                },
                inliner: {
                    additionalProperties: false,
                    defaultProperties: [],
                    properties: {
                        active: {
                            type: 'boolean'
                        }
                    },
                    type: 'object'
                },
                security: {
                    additionalProperties: false,
                    defaultProperties: [],
                    properties: {
                        csp: {
                            type: 'string'
                        }
                    },
                    type: 'object'
                },
                window: {
                    additionalProperties: false,
                    defaultProperties: [],
                    properties: {
                        fullscreen: {
                            type: 'boolean'
                        },
                        height: {
                            type: 'number'
                        },
                        resizable: {
                            type: 'boolean'
                        },
                        title: {
                            type: 'string'
                        },
                        width: {
                            type: 'number'
                        }
                    },
                    required: ['title'],
                    type: 'object'
                }
            },
            required: [
                'allowlist',
                'bundle',
                'embeddedServer',
                'inliner',
                'security',
                'window'
            ],
            type: 'object'
        },
        verbose: {
            description: 'Whether or not to enable verbose logging',
            type: 'boolean'
        }
    },
    required: ['build', 'ctx', 'tauri'],
    type: 'object'
};
exports.isTauriConfig = exports.ajv.compile(exports.TauriConfigSchema);
function validate(value) {
    if (exports.isTauriConfig(value)) {
        return value;
    }
    else {
        throw new Error(exports.ajv.errorsText(exports.isTauriConfig.errors.filter(function (e) { return e.keyword !== 'if'; }), { dataVar: 'TauriConfig' }) +
            '\n\n' +
            util_1.inspect(value));
    }
}
exports.default = validate;


/***/ }),

/***/ "ajv":
/*!**********************!*\
  !*** external "ajv" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("ajv");;

/***/ }),

/***/ "ajv/lib/refs/json-schema-draft-06.json":
/*!*********************************************************!*\
  !*** external "ajv/lib/refs/json-schema-draft-06.json" ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = require("ajv/lib/refs/json-schema-draft-06.json");;

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/***/ ((module) => {

module.exports = require("chalk");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");;

/***/ }),

/***/ "fs-extra":
/*!***************************!*\
  !*** external "fs-extra" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("fs-extra");;

/***/ }),

/***/ "ms":
/*!*********************!*\
  !*** external "ms" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("ms");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");;

/***/ }),

/***/ "webpack-merge":
/*!********************************!*\
  !*** external "webpack-merge" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("webpack-merge");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/helpers/tauri-config.ts");
/******/ })()
;
});
//# sourceMappingURL=tauri-config.js.map