(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["tauri"] = factory();
	else
		root["tauri"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/api/tauricon.ts":
/*!*****************************!*\
  !*** ./src/api/tauricon.ts ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call */
/**
 * This is a module that takes an original image and resizes
 * it to common icon sizes and will put them in a folder.
 * It will retain transparency and can make special file
 * types. You can control the settings.
 *
 * @module tauricon
 * @exports tauricon
 * @author Daniel Thompson-Yvetot
 * @license MIT
 */
var fs_extra_1 = __webpack_require__(/*! fs-extra */ "fs-extra");
var imagemin_1 = __importDefault(__webpack_require__(/*! imagemin */ "imagemin"));
var imagemin_optipng_1 = __importDefault(__webpack_require__(/*! imagemin-optipng */ "imagemin-optipng"));
var imagemin_pngquant_1 = __importDefault(__webpack_require__(/*! imagemin-pngquant */ "imagemin-pngquant"));
var imagemin_zopfli_1 = __importDefault(__webpack_require__(/*! imagemin-zopfli */ "imagemin-zopfli"));
var is_png_1 = __importDefault(__webpack_require__(/*! is-png */ "is-png"));
var path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
var png2icons = __importStar(__webpack_require__(/*! png2icons */ "png2icons"));
var read_chunk_1 = __importDefault(__webpack_require__(/*! read-chunk */ "read-chunk"));
var sharp_1 = __importDefault(__webpack_require__(/*! sharp */ "sharp"));
var app_paths_1 = __webpack_require__(/*! ../helpers/app-paths */ "./src/helpers/app-paths.ts");
var logger_1 = __importDefault(__webpack_require__(/*! ../helpers/logger */ "./src/helpers/logger.ts"));
var settings = __importStar(__webpack_require__(/*! ../helpers/tauricon.config */ "./src/helpers/tauricon.config.ts"));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var package_json_1 = __webpack_require__(/*! ../../package.json */ "./package.json");
var log = logger_1.default('app:spawn');
var warn = logger_1.default('app:spawn', chalk_1.default.red);
var image = false;
var spinnerInterval = false;
var exists = function (file) {
    return __awaiter(this, void 0, void 0, function () {
        var err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fs_extra_1.access(file)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, true];
                case 2:
                    err_1 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
};
/**
 * This is the first call that attempts to memoize the sharp(src).
 * If the source image cannot be found or if it is not a png, it
 * is a failsafe that will exit or throw.
 *
 * @param {string} src - a folder to target
 * @exits {error} if not a png, if not an image
 */
var checkSrc = function (src) { return __awaiter(void 0, void 0, void 0, function () {
    var srcExists, buffer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(image !== false)) return [3 /*break*/, 1];
                return [2 /*return*/, image];
            case 1: return [4 /*yield*/, exists(src)];
            case 2:
                srcExists = _a.sent();
                if (!!srcExists) return [3 /*break*/, 3];
                image = false;
                if (spinnerInterval)
                    clearInterval(spinnerInterval);
                warn('[ERROR] Source image for tauricon not found');
                process.exit(1);
                return [3 /*break*/, 5];
            case 3: return [4 /*yield*/, read_chunk_1.default(src, 0, 8)];
            case 4:
                buffer = _a.sent();
                if (is_png_1.default(buffer)) {
                    return [2 /*return*/, (image = sharp_1.default(src))];
                }
                else {
                    image = false;
                    if (spinnerInterval)
                        clearInterval(spinnerInterval);
                    warn('[ERROR] Source image for tauricon is not a png');
                    process.exit(1);
                }
                _a.label = 5;
            case 5: return [2 /*return*/];
        }
    });
}); };
/**
 * Sort the folders in the current job for unique folders.
 *
 * @param {object} options - a subset of the settings
 * @returns {array} folders
 */
// TODO: proper type of options and folders
var uniqueFolders = function (options) {
    var folders = [];
    for (var type in options) {
        var option = options[String(type)];
        if (option.folder) {
            folders.push(option.folder);
        }
    }
    // TODO: is compare argument required?
    // eslint-disable-next-line @typescript-eslint/require-array-sort-compare
    folders = folders.sort().filter(function (x, i, a) { return !i || x !== a[i - 1]; });
    return folders;
};
/**
 * Turn a hex color (like #212342) into r,g,b values
 *
 * @param {string} hex - hex colour
 * @returns {array} r,g,b
 */
var hexToRgb = function (hex) {
    // https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        }
        : undefined;
};
/**
 * validate image and directory
 */
var validate = function (src, target) { return __awaiter(void 0, void 0, void 0, function () {
    var res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(target !== undefined)) return [3 /*break*/, 2];
                return [4 /*yield*/, fs_extra_1.ensureDir(target)];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [4 /*yield*/, checkSrc(src)];
            case 3:
                res = _a.sent();
                return [2 /*return*/, res];
        }
    });
}); };
// TODO: should take end param?
/**
 * Log progress in the command line
 *
 * @param {boolean} end
 */
var progress = function (msg) {
    process.stdout.write("  " + msg + "                       \r");
};
/**
 * Create a spinner on the command line
 *
 * @example
 *
 *     const spinnerInterval = spinner()
 *     // later
 *     clearInterval(spinnerInterval)
 */
var spinner = function () {
    return setInterval(function () {
        process.stdout.write('/ \r');
        setTimeout(function () {
            process.stdout.write('- \r');
            setTimeout(function () {
                process.stdout.write('\\ \r');
                setTimeout(function () {
                    process.stdout.write('| \r');
                }, 100);
            }, 100);
        }, 100);
    }, 500);
};
var tauricon = (exports.tauricon = {
    validate: function (src, target) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, validate(src, target)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, typeof image === 'object'];
                }
            });
        });
    },
    version: function () {
        return package_json_1.version;
    },
    make: function (src, target, strategy, 
    // TODO: proper type for options
    options) {
        if (src === void 0) { src = path_1.default.resolve(app_paths_1.appDir, 'app-icon.png'); }
        if (target === void 0) { target = path_1.default.resolve(app_paths_1.tauriDir, 'icons'); }
        return __awaiter(this, void 0, void 0, function () {
            var spinnerInterval;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spinnerInterval = spinner();
                        options = options || settings.options.tauri;
                        return [4 /*yield*/, this.validate(src, target)];
                    case 1:
                        _a.sent();
                        progress('Building Tauri icns and ico');
                        return [4 /*yield*/, this.icns(src, target, options, strategy)];
                    case 2:
                        _a.sent();
                        progress('Building Tauri png icons');
                        return [4 /*yield*/, this.build(src, target, options)];
                    case 3:
                        _a.sent();
                        if (!strategy) return [3 /*break*/, 5];
                        progress("Minifying assets with " + strategy);
                        return [4 /*yield*/, this.minify(target, options, strategy, 'batch')];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        log('no minify strategy');
                        _a.label = 6;
                    case 6:
                        progress('Tauricon Finished');
                        clearInterval(spinnerInterval);
                        return [2 /*return*/, true];
                }
            });
        });
    },
    /**
     * Creates a set of images according to the subset of options it knows about.
     *
     * @param {string} src - image location
     * @param {string} target - where to drop the images
     * @param {object} options - js object that defines path and sizes
     */
    build: function (src, target, 
    // TODO: proper type for options
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var sharpSrc, buildify2, output, folders, n, folder, _a, _b, _i, optionKey, option, _c, _d, _e, sizeKey, size, dest, pvar;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0: return [4 /*yield*/, this.validate(src, target)];
                    case 1:
                        _f.sent();
                        sharpSrc = sharp_1.default(src) // creates the image object
                        ;
                        buildify2 = function (pvar) {
                            return __awaiter(this, void 0, void 0, function () {
                                var pngImage, rgb, err_2;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 2, , 3]);
                                            pngImage = sharpSrc.resize(pvar[1], pvar[1]);
                                            if (pvar[2]) {
                                                rgb = hexToRgb(options.background_color) || {
                                                    r: undefined,
                                                    g: undefined,
                                                    b: undefined
                                                };
                                                pngImage.flatten({
                                                    background: { r: rgb.r, g: rgb.g, b: rgb.b, alpha: 1 }
                                                });
                                            }
                                            pngImage.png();
                                            return [4 /*yield*/, pngImage.toFile(pvar[0])];
                                        case 1:
                                            _a.sent();
                                            return [3 /*break*/, 3];
                                        case 2:
                                            err_2 = _a.sent();
                                            warn(err_2);
                                            return [3 /*break*/, 3];
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            });
                        };
                        folders = uniqueFolders(options);
                        // eslint-disable-next-line @typescript-eslint/no-for-in-array
                        for (n in folders) {
                            folder = folders[Number(n)];
                            // make the folders first
                            // TODO: should this be ensureDirSync?
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            fs_extra_1.ensureDir("" + target + path_1.default.sep + folder);
                        }
                        _a = [];
                        for (_b in options)
                            _a.push(_b);
                        _i = 0;
                        _f.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        optionKey = _a[_i];
                        option = options[String(optionKey)];
                        _c = [];
                        for (_d in option.sizes)
                            _c.push(_d);
                        _e = 0;
                        _f.label = 3;
                    case 3:
                        if (!(_e < _c.length)) return [3 /*break*/, 6];
                        sizeKey = _c[_e];
                        size = option.sizes[String(sizeKey)];
                        if (!!option.splash) return [3 /*break*/, 5];
                        dest = target + "/" + option.folder;
                        if (option.infix === true) {
                            output = "" + dest + path_1.default.sep + option.prefix + size + "x" + size + option.suffix;
                        }
                        else {
                            output = "" + dest + path_1.default.sep + option.prefix + option.suffix;
                        }
                        pvar = [
                            output,
                            size,
                            option.background
                        ];
                        return [4 /*yield*/, buildify2(pvar)];
                    case 4:
                        _f.sent();
                        _f.label = 5;
                    case 5:
                        _e++;
                        return [3 /*break*/, 3];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/];
                }
            });
        });
    },
    /**
     * Creates a set of splash images (COMING SOON!!!)
     *
     * @param {string} src - icon location
     * @param {string} splashSrc - splashscreen location
     * @param {string} target - where to drop the images
     * @param {object} options - js object that defines path and sizes
     */
    splash: function (src, splashSrc, target, 
    // TODO: proper type for options
    options) {
        return __awaiter(this, void 0, void 0, function () {
            var output, block, rgb, sharpSrc, data, _a, _b, _i, optionKey, option, _c, _d, _e, sizeKey, size, dest, pvar, sharpData;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        block = false;
                        rgb = hexToRgb(options.background_color) || {
                            r: undefined,
                            g: undefined,
                            b: undefined
                        };
                        if (splashSrc === src) {
                            // prevent overlay or pure
                            block = true;
                        }
                        if (!(block || options.splashscreen_type === 'generate')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.validate(src, target)];
                    case 1:
                        _f.sent();
                        if (!image) {
                            process.exit(1);
                        }
                        sharpSrc = sharp_1.default(src);
                        sharpSrc
                            .extend({
                            top: 726,
                            bottom: 726,
                            left: 726,
                            right: 726,
                            background: {
                                r: rgb.r,
                                g: rgb.g,
                                b: rgb.b,
                                alpha: 1
                            }
                        })
                            .flatten({ background: { r: rgb.r, g: rgb.g, b: rgb.b, alpha: 1 } });
                        return [3 /*break*/, 3];
                    case 2:
                        if (options.splashscreen_type === 'overlay') {
                            sharpSrc = sharp_1.default(splashSrc)
                                .flatten({ background: { r: rgb.r, g: rgb.g, b: rgb.b, alpha: 1 } })
                                .composite([
                                {
                                    input: src
                                    // blend: 'multiply' <= future work, maybe just a gag
                                }
                            ]);
                        }
                        else if (options.splashscreen_type === 'pure') {
                            sharpSrc = sharp_1.default(splashSrc).flatten({
                                background: { r: rgb.r, g: rgb.g, b: rgb.b, alpha: 1 }
                            });
                        }
                        else {
                            throw new Error("unknown options.splashscreen_type: " + options.splashscreen_type);
                        }
                        _f.label = 3;
                    case 3: return [4 /*yield*/, sharpSrc.toBuffer()];
                    case 4:
                        data = _f.sent();
                        _a = [];
                        for (_b in options)
                            _a.push(_b);
                        _i = 0;
                        _f.label = 5;
                    case 5:
                        if (!(_i < _a.length)) return [3 /*break*/, 11];
                        optionKey = _a[_i];
                        option = options[String(optionKey)];
                        _c = [];
                        for (_d in option.sizes)
                            _c.push(_d);
                        _e = 0;
                        _f.label = 6;
                    case 6:
                        if (!(_e < _c.length)) return [3 /*break*/, 10];
                        sizeKey = _c[_e];
                        size = option.sizes[String(sizeKey)];
                        if (!option.splash) return [3 /*break*/, 9];
                        dest = "" + target + path_1.default.sep + option.folder;
                        return [4 /*yield*/, fs_extra_1.ensureDir(dest)];
                    case 7:
                        _f.sent();
                        if (option.infix === true) {
                            output = "" + dest + path_1.default.sep + option.prefix + size + "x" + size + option.suffix;
                        }
                        else {
                            output = "" + dest + path_1.default.sep + option.prefix + option.suffix;
                        }
                        pvar = [output, size];
                        sharpData = sharp_1.default(data);
                        sharpData = sharpData.resize(pvar[1][0], pvar[1][1]);
                        return [4 /*yield*/, sharpData.toFile(pvar[0])];
                    case 8:
                        _f.sent();
                        _f.label = 9;
                    case 9:
                        _e++;
                        return [3 /*break*/, 6];
                    case 10:
                        _i++;
                        return [3 /*break*/, 5];
                    case 11: return [2 /*return*/];
                }
            });
        });
    },
    /**
     * Minifies a set of images
     *
     * @param {string} target - image location
     * @param {object} options - where to drop the images
     * @param {string} strategy - which minify strategy to use
     * @param {string} mode - singlefile or batch
     */
    minify: function (target, 
    // TODO: proper type for options
    options, strategy, mode) {
        return __awaiter(this, void 0, void 0, function () {
            var cmd, minify, minifier, _a, folders, _b, _c, _i, n, folder;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        minify = settings.options.minify;
                        if (!minify.available.find(function (x) { return x === strategy; })) {
                            strategy = minify.type;
                        }
                        switch (strategy) {
                            case 'pngquant':
                                // TODO: is minify.pngquantOptions the proper format?
                                cmd = imagemin_pngquant_1.default(minify.pngquantOptions);
                                break;
                            case 'optipng':
                                cmd = imagemin_optipng_1.default(minify.optipngOptions);
                                break;
                            case 'zopfli':
                                cmd = imagemin_zopfli_1.default(minify.zopfliOptions);
                                break;
                            default:
                                throw new Error('unknown strategy' + strategy);
                        }
                        minifier = function (pvar, cmd) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, imagemin_1.default([pvar[0]], {
                                            destination: pvar[1],
                                            plugins: [cmd]
                                        }).catch(function (err) {
                                            warn(err);
                                        })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        _a = mode;
                        switch (_a) {
                            case 'singlefile': return [3 /*break*/, 1];
                            case 'batch': return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 8];
                    case 1: return [4 /*yield*/, minifier([target, path_1.default.dirname(target)], cmd)];
                    case 2:
                        _d.sent();
                        return [3 /*break*/, 9];
                    case 3:
                        folders = uniqueFolders(options);
                        _b = [];
                        for (_c in folders)
                            _b.push(_c);
                        _i = 0;
                        _d.label = 4;
                    case 4:
                        if (!(_i < _b.length)) return [3 /*break*/, 7];
                        n = _b[_i];
                        folder = folders[Number(n)];
                        log('batch minify:' + String(folder));
                        return [4 /*yield*/, minifier([
                                "" + target + path_1.default.sep + folder + path_1.default.sep + "*.png",
                                "" + target + path_1.default.sep + folder
                            ], cmd)];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        warn('[ERROR] Minify mode must be one of [ singlefile | batch]');
                        process.exit(1);
                        _d.label = 9;
                    case 9: return [2 /*return*/, 'minified'];
                }
            });
        });
    },
    /**
     * Creates special icns and ico filetypes
     *
     * @param {string} src - image location
     * @param {string} target - where to drop the images
     * @param {object} options
     * @param {string} strategy
     */
    icns: function (src, target, 
    // TODO: proper type for options
    options, strategy) {
        return __awaiter(this, void 0, void 0, function () {
            var sharpSrc, buf, out, out2, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        if (!image) {
                            process.exit(1);
                        }
                        return [4 /*yield*/, this.validate(src, target)];
                    case 1:
                        _a.sent();
                        sharpSrc = sharp_1.default(src);
                        return [4 /*yield*/, sharpSrc.toBuffer()];
                    case 2:
                        buf = _a.sent();
                        out = png2icons.createICNS(buf, png2icons.BICUBIC, 0);
                        if (out === null) {
                            throw new Error('Failed to create icon.icns');
                        }
                        fs_extra_1.ensureFileSync(path_1.default.join(target, '/icon.icns'));
                        fs_extra_1.writeFileSync(path_1.default.join(target, '/icon.icns'), out);
                        out2 = png2icons.createICO(buf, png2icons.BICUBIC, 0, true);
                        if (out2 === null) {
                            throw new Error('Failed to create icon.ico');
                        }
                        fs_extra_1.ensureFileSync(path_1.default.join(target, '/icon.ico'));
                        fs_extra_1.writeFileSync(path_1.default.join(target, '/icon.ico'), out2);
                        return [3 /*break*/, 4];
                    case 3:
                        err_3 = _a.sent();
                        console.error(err_3);
                        throw err_3;
                    case 4: return [2 /*return*/];
                }
            });
        });
    }
});
/* eslint-enable @typescript-eslint/restrict-template-expressions */
if (true) {
    if ( true && module.exports) {
        exports = module.exports = tauricon;
    }
    exports.tauricon = tauricon;
}


/***/ }),

/***/ "./src/helpers/app-paths.ts":
/*!**********************************!*\
  !*** ./src/helpers/app-paths.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolve = exports.tauriDir = exports.appDir = void 0;
var fs_1 = __webpack_require__(/*! fs */ "fs");
var path_1 = __webpack_require__(/*! path */ "path");
var logger_1 = __importDefault(__webpack_require__(/*! ./logger */ "./src/helpers/logger.ts"));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var warn = logger_1.default('tauri', chalk_1.default.red);
function resolvePath(basePath, dir) {
    return dir && path_1.isAbsolute(dir) ? dir : path_1.resolve(basePath, dir);
}
var getAppDir = function () {
    var dir = process.cwd();
    var count = 0;
    // only go up three folders max
    while (dir.length > 0 && !dir.endsWith(path_1.sep) && count <= 2) {
        if (fs_1.existsSync(path_1.join(dir, 'src-tauri', 'tauri.conf.json'))) {
            return dir;
        }
        count++;
        dir = path_1.normalize(path_1.join(dir, '..'));
    }
    warn("Couldn't find recognize the current folder as a part of a Tauri project");
    process.exit(1);
};
var appDir = getAppDir();
exports.appDir = appDir;
var tauriDir = path_1.resolve(appDir, 'src-tauri');
exports.tauriDir = tauriDir;
var resolveDir = {
    app: function (dir) { return resolvePath(appDir, dir); },
    tauri: function (dir) { return resolvePath(tauriDir, dir); }
};
exports.resolve = resolveDir;


/***/ }),

/***/ "./src/helpers/logger.ts":
/*!*******************************!*\
  !*** ./src/helpers/logger.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
var ms_1 = __importDefault(__webpack_require__(/*! ms */ "ms"));
var prevTime;
exports.default = (function (banner, color) {
    if (color === void 0) { color = chalk_1.default.green; }
    return function (msg) {
        var curr = +new Date();
        var diff = curr - (prevTime || curr);
        prevTime = curr;
        if (msg) {
            console.log(
            // TODO: proper typings for color and banner
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-unsafe-call
            " " + color(String(banner)) + " " + msg + " " + chalk_1.default.green("+" + ms_1.default(diff)));
        }
        else {
            console.log();
        }
    };
});


/***/ }),

/***/ "./src/helpers/tauricon.config.ts":
/*!****************************************!*\
  !*** ./src/helpers/tauricon.config.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.options = void 0;
exports.options = {
    // folder determines in which path to drop the generated file
    // prefix is the first part of the generated file's name
    // infix adds e.g. '44x44' based on the size in sizes to the generated file's name
    // suffix adds a file-ending to the generated file's name
    // sizes determines the pixel width and height to use
    background_color: '#000074',
    theme_color: '#02aa9b',
    sharp: 'kernel: sharp.kernel.lanczos3',
    minify: {
        batch: false,
        overwrite: true,
        available: ['pngquant', 'optipng', 'zopfli'],
        type: 'pngquant',
        pngcrushOptions: {
            reduce: true
        },
        pngquantOptions: {
            quality: [0.6, 0.8],
            floyd: 0.1,
            speed: 10 // 1 - 10
        },
        optipngOptions: {
            optimizationLevel: 4,
            bitDepthReduction: true,
            colorTypeReduction: true,
            paletteReduction: true
        },
        zopfliOptions: {
            transparent: true,
            more: true
        }
    },
    splash_type: 'generate',
    tauri: {
        linux: {
            folder: '.',
            prefix: '',
            infix: true,
            suffix: '.png',
            sizes: [32, 128]
        },
        linux_2x: {
            folder: '.',
            prefix: '128x128@2x',
            infix: false,
            suffix: '.png',
            sizes: [256]
        },
        defaults: {
            folder: '.',
            prefix: 'icon',
            infix: false,
            suffix: '.png',
            sizes: [512]
        },
        appx_logo: {
            folder: '.',
            prefix: 'StoreLogo',
            infix: false,
            suffix: '.png',
            sizes: [50]
        },
        appx_square: {
            folder: '.',
            prefix: 'Square',
            infix: true,
            suffix: 'Logo.png',
            sizes: [30, 44, 71, 89, 107, 142, 150, 284, 310]
        }
        // todo: look at capacitor and cordova for insight into what icons
        // we need for those distribution targets
    }
};


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = JSON.parse("{\"name\":\"tauri\",\"version\":\"0.15.0\",\"description\":\"Multi-binding collection of libraries and templates for building Tauri apps\",\"funding\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/tauri\"},\"scripts\":{\"postinstall\":\"node warning.js\",\"build\":\"yarn build:api && yarn build:webpack\",\"build:webpack\":\"rimraf ./dist && yarn build:typevalidators && webpack --progress\",\"build:typevalidators\":\"node ./build/type-validators\",\"build:api\":\"rimraf ./api && rollup -c --silent\",\"build-release\":\"yarn build:api && rimraf ./dist && yarn build:typevalidators && webpack\",\"test\":\"jest --runInBand --no-cache --testPathIgnorePatterns=\\\"(build|dev)\\\"\",\"pretest\":\"yarn build\",\"prepublishOnly\":\"yarn build-release\",\"test:local\":\"jest --runInBand\",\"lint\":\"eslint --ext ts \\\"./src/**/*.ts\\\" \\\"./api-src/**/*.ts\\\"\",\"lint-fix\":\"eslint --fix --ext ts \\\"./src/**/*.ts\\\" \\\"./api-src/**/*.ts\\\"\",\"lint:lockfile\":\"lockfile-lint --path yarn.lock --type yarn --validate-https --allowed-hosts npm yarn\",\"format\":\"prettier --write --end-of-line=auto !./**/mutation-observer.js !./**/config.validator.js \\\"./**/*.{js,jsx,ts,tsx,html,css,json}\\\" --ignore-path .gitignore\",\"format:check\":\"prettier --check --end-of-line=auto !./**/mutation-observer.js \\\"./**/*.{js,jsx,ts,tsx,html,css,json}\\\" --ignore-path .gitignore\",\"build:tauri[rust]\":\"cd ../tauri && TAURI_DIST_DIR=../../test/fixture/dist TAURI_DIR=../test/fixture cargo publish --dry-run --allow-dirty\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/tauri-apps/tauri.git\"},\"contributors\":[\"Tauri Team <team@tauri-apps.org> (https://tauri.studio)\",\"Daniel Thompson-Yvetot <denjell@sfosc.org>\",\"Lucas Fernandes Gonçalves Nogueira <lucas@tauri.studio>\"],\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/tauri-apps/tauri/issues\"},\"homepage\":\"https://github.com/tauri-apps/tauri#readme\",\"publishConfig\":{\"access\":\"public\"},\"engines\":{\"node\":\">= 10.17.0\",\"npm\":\">= 6.6.0\",\"yarn\":\">= 1.19.1\"},\"dependencies\":{\"@tauri-apps/tauri-inliner\":\"1.14.1\",\"@tauri-apps/toml\":\"2.2.4\",\"chalk\":\"4.1.0\",\"chokidar\":\"3.5.0\",\"cross-spawn\":\"7.0.3\",\"fast-glob\":\"3.2.4\",\"fs-extra\":\"9.0.1\",\"http-proxy\":\"1.18.1\",\"imagemin\":\"7.0.1\",\"imagemin-optipng\":\"8.0.0\",\"imagemin-pngquant\":\"9.0.1\",\"imagemin-zopfli\":\"7.0.0\",\"inquirer\":\"7.3.3\",\"is-png\":\"2.0.0\",\"is-reachable\":\"5.0.0\",\"isbinaryfile\":\"4.0.6\",\"jsdom\":\"16.4.0\",\"lodash\":\"4.17.20\",\"minimist\":\"1.2.5\",\"ms\":\"2.1.3\",\"png2icons\":\"2.0.1\",\"read-chunk\":\"3.2.0\",\"semver\":\"7.3.4\",\"sharp\":\"0.27.0\",\"webpack-merge\":\"5.7.3\",\"webpack-shell-plugin\":\"0.5.0\"},\"devDependencies\":{\"@babel/core\":\"7.12.10\",\"@babel/preset-env\":\"7.12.11\",\"@babel/preset-typescript\":\"7.12.7\",\"@rollup/plugin-babel\":\"5.2.2\",\"@rollup/plugin-commonjs\":\"17.0.0\",\"@rollup/plugin-json\":\"4.1.0\",\"@rollup/plugin-node-resolve\":\"11.0.1\",\"@rollup/plugin-sucrase\":\"3.1.0\",\"@rollup/plugin-typescript\":\"8.1.0\",\"@types/cross-spawn\":\"6.0.2\",\"@types/fs-extra\":\"9.0.6\",\"@types/http-proxy\":\"1.17.4\",\"@types/imagemin\":\"7.0.0\",\"@types/imagemin-optipng\":\"5.2.0\",\"@types/inquirer\":\"7.3.1\",\"@types/jsdom\":\"16.2.5\",\"@types/lodash\":\"4.14.167\",\"@types/ms\":\"0.7.31\",\"@types/semver\":\"7.3.4\",\"@types/sharp\":\"0.27.0\",\"@typescript-eslint/eslint-plugin\":\"4.12.0\",\"@typescript-eslint/parser\":\"4.12.0\",\"babel-jest\":\"26.6.3\",\"copy-webpack-plugin\":\"7.0.0\",\"dotenv\":\"8.2.0\",\"eslint\":\"7.17.0\",\"eslint-config-prettier\":\"7.1.0\",\"eslint-config-standard-with-typescript\":\"19.0.1\",\"eslint-plugin-import\":\"2.22.1\",\"eslint-plugin-lodash-template\":\"0.19.0\",\"eslint-plugin-node\":\"11.1.0\",\"eslint-plugin-promise\":\"4.2.1\",\"eslint-plugin-security\":\"1.4.0\",\"eslint-plugin-standard\":\"4.1.0\",\"husky\":\"4.3.6\",\"is-running\":\"2.1.0\",\"jest\":\"26.6.3\",\"jest-mock-process\":\"1.4.0\",\"lint-staged\":\"10.5.3\",\"lockfile-lint\":\"4.3.7\",\"prettier\":\"2.2.1\",\"promise\":\"8.1.0\",\"raw-loader\":\"4.0.2\",\"rimraf\":\"3.0.2\",\"rollup\":\"2.36.0\",\"rollup-plugin-terser\":\"7.0.2\",\"rollup-plugin-typescript2\":\"0.29.0\",\"toml-loader\":\"1.0.0\",\"ts-loader\":\"8.0.14\",\"tslib\":\"2.1.0\",\"typescript\":\"4.1.3\",\"typescript-json-validator\":\"2.4.2\",\"webpack\":\"5.11.1\",\"webpack-cli\":\"4.3.1\",\"webpack-node-externals\":\"2.5.2\"},\"resolutions\":{\"**/lodash\":\">=4.17.19\"},\"husky\":{\"hooks\":{\"pre-commit\":\"lint-staged\"}},\"lint-staged\":{\"*.{js,jsx,ts,tsx,md,html,css,json}\":\"prettier --write --end-of-line=auto !./**/mutation-observer.js !./**/config.validator.js \\\"./**/*.{js,jsx,ts,tsx,html,css,json}\\\" --ignore-path .gitignore\",\"*.{ts,tsx}\":\"eslint --fix --ext ts ./src/**/*.ts ./api-src/**/*.ts\"}}");

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/***/ ((module) => {

module.exports = require("chalk");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");;

/***/ }),

/***/ "fs-extra":
/*!***************************!*\
  !*** external "fs-extra" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("fs-extra");;

/***/ }),

/***/ "imagemin":
/*!***************************!*\
  !*** external "imagemin" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("imagemin");;

/***/ }),

/***/ "imagemin-optipng":
/*!***********************************!*\
  !*** external "imagemin-optipng" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("imagemin-optipng");;

/***/ }),

/***/ "imagemin-pngquant":
/*!************************************!*\
  !*** external "imagemin-pngquant" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("imagemin-pngquant");;

/***/ }),

/***/ "imagemin-zopfli":
/*!**********************************!*\
  !*** external "imagemin-zopfli" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("imagemin-zopfli");;

/***/ }),

/***/ "is-png":
/*!*************************!*\
  !*** external "is-png" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("is-png");;

/***/ }),

/***/ "ms":
/*!*********************!*\
  !*** external "ms" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("ms");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");;

/***/ }),

/***/ "png2icons":
/*!****************************!*\
  !*** external "png2icons" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("png2icons");;

/***/ }),

/***/ "read-chunk":
/*!*****************************!*\
  !*** external "read-chunk" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("read-chunk");;

/***/ }),

/***/ "sharp":
/*!************************!*\
  !*** external "sharp" ***!
  \************************/
/***/ ((module) => {

module.exports = require("sharp");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/api/tauricon.ts");
/******/ })()
;
});
//# sourceMappingURL=tauricon.js.map